import glob
import os
import sys
import shutil
import time
import subprocess
from datetime import datetime


import config


def name(case_fn):
    fn = os.path.basename(case_fn)
    return fn.replace(".leaf.der", "").replace(".der", "").replace("-", "_")


def emit_header(f):
    print(
        """//
// AUTOGENERATED by %s on %s -- do not edit
//

use std::convert::TryFrom;

use webpki;

static ALL_SIG_ALGS: &[&webpki::SignatureAlgorithm] = &[
    &webpki::ECDSA_P256_SHA256,
    &webpki::ECDSA_P256_SHA384,
    &webpki::ECDSA_P384_SHA256,
    &webpki::ECDSA_P384_SHA384,
    &webpki::ED25519,
    &webpki::RSA_PKCS1_2048_8192_SHA256,
    &webpki::RSA_PKCS1_2048_8192_SHA384,
    &webpki::RSA_PKCS1_2048_8192_SHA512,
    &webpki::RSA_PKCS1_3072_8192_SHA384,
];
"""
        % (sys.argv[0], datetime.utcnow().isoformat()),
        file=f,
    )


def introduce(f, testname):
    print(
        """#[test]
fn test_%s() {"""
        % testname,
        file=f,
    )


def end(f):
    print(
        """}
""",
        file=f,
    )


def get_ca(f):
    if not os.path.exists("data/fake-ca.der"):
        subprocess.check_call(
            [
                "openssl",
                "asn1parse",
                "-inform",
                "PEM",
                "-noout",
                "-in",
                "x509test/ca/fake-ca.cert",
                "-out",
                "data/fake-ca.der",
            ]
        )
    print(
        """    let ca = include_bytes!("data/fake-ca.der");
    let ca = webpki::TrustAnchor::try_from_cert_der(&ca[..])
        .expect("cannot parse ca cert");""",
        file=f,
    )


def _prepare_chain(_chain):
    chain = []
    for c in _chain:
        target = os.path.join("data", os.path.basename(c))
        shutil.copyfile(c, target)
        chain.append(target)

    leaf, rest = chain[0], chain[1:]
    return leaf, rest


def valid_chain(f, _chain):
    leaf, rest = _prepare_chain(_chain)

    print("""    let intermediates = [""", file=f)
    for r in rest:
        print("""        &include_bytes!("%s")[..],""" % r, file=f)
    print("""    ];""", file=f)

    print(
        """    let ee = webpki::EndEntityCert::try_from(&include_bytes!("%s")[..])
        .expect("cannot parse valid ee cert");
    ee.verify_is_valid_tls_server_cert(&ALL_SIG_ALGS,
                                       &webpki::TlsServerTrustAnchors(&[ca]),
                                       &intermediates[..],
                                       webpki::Time::from_seconds_since_unix_epoch(%d))
        .expect("ee cert should be valid");"""
        % (leaf, int(time.time())),
        file=f,
    )


def invalid_chain(f, _chain, error):
    leaf, rest = _prepare_chain(_chain)

    print("""    let intermediates = [""", file=f)
    for r in rest:
        print("""        &include_bytes!("%s")[..],""" % r, file=f)
    print("""    ];""", file=f)

    print(
        """    assert_eq!(
        webpki::EndEntityCert::try_from(&include_bytes!("%s")[..])
            .and_then(|ee| {
                ee.verify_is_valid_tls_server_cert(&ALL_SIG_ALGS,
                                                   &webpki::TlsServerTrustAnchors(&[ca]),
                                                   &intermediates[..],
                                                   webpki::Time::from_seconds_since_unix_epoch(%d))?;
                Ok(ee)
            })
            .and_then(|ee| {
                ee.verify_is_valid_for_subject_name(webpki::DnsNameRef::try_from_ascii_str("example.com").unwrap())
            })
            .expect_err("ee cert/chain/name expected to be invalid"),
        webpki::Error::%s
    );"""
        % (leaf, int(time.time()), error),
        file=f,
    )


def emit_anchor_case(f, case, cert):
    n = name(case)
    cert, _ = _prepare_chain([cert])
    error = config.tests_apply_to_anchor[n]

    introduce(f, n)
    print(
        """    let ca = include_bytes!("%s");
    assert_eq!(
        webpki::TrustAnchor::try_from_cert_der(&ca[..])"""
        % cert,
        file=f,
    )

    if error:
        print(
            """        .expect_err("anchor parsing error expected"),
        webpki::Error::%s
    );"""
            % error,
            file=f,
        )
    else:
        print(
            """        .is_ok(), true
    );""",
            file=f,
        )
    end(f)


def emit_valid_case(f, case, chain):
    n = name(case)
    if n in config.skip_tests:
        print("WARN:", n, "is skipped")
        return
    if n in config.tests_apply_to_anchor:
        assert len(chain) == 1
        return emit_anchor_case(f, case, chain[0])
    if n in config.error_for_ok_test:
        print("INFO: valid test", n, "diverted to error")
        return emit_invalid_case(f, case, chain, error=config.error_for_ok_test[n])
    introduce(f, n)
    get_ca(f)
    valid_chain(f, chain)
    end(f)


def emit_single_valid_case(f, case):
    emit_valid_case(f, case, [case])


def emit_double_valid_case(f, case):
    emit_valid_case(f, case, [case, case.replace(".leaf", ".ca")])


def emit_invalid_case(f, case, chain, error=None):
    n = name(case)
    if n in config.skip_tests:
        print("WARN:", n, "is skipped")
        return
    if n in config.tests_apply_to_anchor:
        assert len(chain) == 1
        return emit_anchor_case(f, case, chain[0])
    if error is None:
        error = config.error_for_xf_test.get(n, None)
        if error is None:
            print("WARN: no expected error for", n, "-- skipped")
            return
    introduce(f, n)
    get_ca(f)
    invalid_chain(f, chain, error)
    end(f)


def emit_single_invalid_case(f, case):
    emit_invalid_case(f, case, [case])


def emit_double_invalid_case(f, case, error=None):
    emit_invalid_case(f, case, [case, case.replace(".leaf", ".ca")])


if __name__ == "__main__":
    os.makedirs(os.path.dirname("data/"), exist_ok=True)

    with open("x509test.rs", "w") as f:
        emit_header(f)

        for case in sorted(glob.glob("x509test/certs/ok-*.der")):
            emit_single_valid_case(f, case)
        for case in sorted(glob.glob("x509test/certs2/ok-*.leaf.der")):
            emit_double_valid_case(f, case)
        for case in sorted(glob.glob("x509test/certs/xf-*.der")):
            emit_single_invalid_case(f, case)
        for case in sorted(glob.glob("x509test/certs2/xf-*.leaf.der")):
            emit_double_invalid_case(f, case)

    subprocess.check_call(["rustfmt", "x509test.rs"])
